---
layout: post
title: Basic Dynamic Range Compressor
author: Chip
---


My last post described <a href="http://openaudio.blogspot.com/2017/01/the-need-for-dynamic-range-compression.html">the need for dynamic range compression</a> in hearing aids: if you amplify enough to hear quiet sounds, loud sounds will become too loud. &nbsp;One solution is to include a Dynamic Range Compressor (<a href="https://en.wikipedia.org/wiki/Dynamic_range_compression">DRC</a>), which changes the gain depending upon the loudness of the signal. &nbsp;Because of the DRC, loud sounds will be amplified less than quiet sounds. &nbsp;Perfect! &nbsp;In this post, I describe how I implemented a DRC and I show its effect on some simple signals.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-LVEJmxCNdMU/WHy_QyXwIJI/AAAAAAAAEIQ/cS1-gYMnr7og-lsgrXYi7FXo8bMcWCQ-ACLcB/s1600/CompressorSignalFlow.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="361" src="https://2.bp.blogspot.com/-LVEJmxCNdMU/WHy_QyXwIJI/AAAAAAAAEIQ/cS1-gYMnr7og-lsgrXYi7FXo8bMcWCQ-ACLcB/s400/CompressorSignalFlow.png" width="400" /></a></div><u>Algorithm Overview:</u>&nbsp; In the figure above, I illustrate the basic signal flow through my DRC algorithm. &nbsp;It's a feed-forward design with a side-chain that computes the time-varying amount of gain that should be applied. &nbsp;The function of each block is described below:<br /><ul><li>Pre-Process Signal: &nbsp;In this block, I apply the "pre-gain", which is the amount of gain that will be applied when the compressor is in its linear regime. &nbsp;Also in this block, I use a high-pass filter to remove any DC offset in the audio signal.</li><li>Level Estimator: &nbsp;For the compressor to vary the gain based on the loudness of the signal, it needs to first estimate the loudness of the signal. &nbsp;That's what this block does.</li><li>Gain Calculator: Using the estimated loudness, this block calculates how much to reduce the gain of the system. &nbsp;It calculates the desired gain reduction knowing the "compression ratio" and "compression threshold" that have been supplied by the user. &nbsp;It also smooths the compressed gain value through time via "attack" and "release" time constants that have been supplied by the user.</li><li>Apply Gain: Once the desired compressed gain value has been calculated by the side-chain, this block applies the gain to the audio signal.</li></ul><u>Arduino/Teensy Implementation:</u>&nbsp; I implemented this algorithm as an C++ class that can be called from any Arduino or Teensy program (see&nbsp;<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">AudioEffectCompressor_F32</span><span style="font-family: inherit;"> in my GitHub library&nbsp;</span><a href="https://github.com/chipaudette/OpenAudio_ArduinoLibrary/blob/master/AudioEffectCompressor_F32.h" style="font-family: inherit;">here</a>)<span style="font-family: inherit;">.</span>&nbsp;It is built upon <a href="http://openaudio.blogspot.com/2016/12/extending-teensy-audio-library-for.html">my F32-extension</a> of the Teensy Audio Library. &nbsp;Because it is so reliant on floating-point operations, it is probably only appropriate for use on the Teensy 3.5 or 3.6 (which have floating-point hardware support) and not the older 3.0, 3.1, or 3.2.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-Ecw6RwjYhHE/WHzDuBFSTFI/AAAAAAAAEIc/EeRj5ad3pxkbGC5H9omHbfqgK1-26b3MACLcB/s1600/GitHubScreenShot.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="278" src="https://3.bp.blogspot.com/-Ecw6RwjYhHE/WHzDuBFSTFI/AAAAAAAAEIc/EeRj5ad3pxkbGC5H9omHbfqgK1-26b3MACLcB/s400/GitHubScreenShot.png" width="400" /></a></div><br /><u>Algorithm Parameters:</u>&nbsp; In the signal flow diagram below, I show the algorithm parameters that are available for the user to set. &nbsp;The main tricky part is how to set the time constant for the Level Estimator. &nbsp;By default, I have this value always scale itself to be 20% of the time constants that the user has set for the Gain Calculator block. &nbsp;If you don't like this default behavior, you can specify your own value using the method&nbsp;<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">setLevelTimeConst_sec()</span><span style="font-family: inherit;">.</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Dk0xue38Guw/WHzDz8VB9ZI/AAAAAAAAEIg/grBMKT1-K-oU-Pa51dPM0aCai-i3SChxQCLcB/s1600/CompressorSignalFlow-wParams.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="336" src="https://1.bp.blogspot.com/-Dk0xue38Guw/WHzDz8VB9ZI/AAAAAAAAEIg/grBMKT1-K-oU-Pa51dPM0aCai-i3SChxQCLcB/s640/CompressorSignalFlow-wParams.png" width="560" /></a></div><u>Example Sketch:</u> &nbsp;As part of including this DRC algorithm in my OpenAudio_ArduinoLibrary (GitHub page <a href="https://github.com/chipaudette/OpenAudio_ArduinoLibrary">here</a>), I made sure to include an example sketch called <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><a href="https://github.com/chipaudette/OpenAudio_ArduinoLibrary/blob/master/examples/BasicCompressor_Float/BasicCompressor_Float.ino">BasicCompressor_Float</a></span><span style="font-family: inherit;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">.</span>&nbsp; </span>This example code assumes that you have a <a href="http://openaudio.blogspot.com/2016/10/teensy-audio-board-first-audio.html">Teensy Audio Board</a> along with a Teensy 3.5/3.6. &nbsp;Within the code, there are a couple of options:<br /><br /><ul><li>USB Audio: &nbsp;For my testing, I chose to send and receive audio over the USB link, instead of via analog audio cables. &nbsp;See&nbsp;<a href="http://openaudio.blogspot.com/2016/10/teensy-audio-over-usb.html">this post</a>, if you want more info on how to use the Teensy's USB Audio link. &nbsp;To enable USB audio in this sketch, set <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">DO_USB</span><span style="font-family: inherit;">&nbsp;to a value of one.</span></li><li><span style="font-family: inherit;">Fast or Slow: &nbsp;Another choice is how to set the values for the compressor's parameters. &nbsp;In my example, I have two sets of parameters. &nbsp;One set gives a "fast" compressor response that is appropriate for quick limiting of very loud sounds. &nbsp;The other set of values gives a "slow" response that can be used as a automatic volume control. &nbsp;For my testing, I chose to use the "fast" response, as shown below.</span></li></ul><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-Rw5T8YtPE20/WH2AGda2-kI/AAAAAAAAEJI/-AnxgCm97s0lAIOwgyM4qE8dPlWfHzlXgCLcB/s1600/ArduinoChooseFastSlow.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="412" src="https://3.bp.blogspot.com/-Rw5T8YtPE20/WH2AGda2-kI/AAAAAAAAEJI/-AnxgCm97s0lAIOwgyM4qE8dPlWfHzlXgCLcB/s640/ArduinoChooseFastSlow.png" width="540" /></a></div><br /><u>Test Setup:</u>&nbsp; For my testing, I'm using my breadboard prototype of my&nbsp;<a href="http://openaudio.blogspot.com/2016/11/a-teensy-hearing-aid.html">Teensy Hearing Aid</a>, which is just a Teensy 3.6 with the Teensy Audio Board (plus microphones, battery, and Bluetooth module, which are not relevant to this test). &nbsp; I've got it plugged into my laptop via USB, which is also used to send and receive audio to the Teensy via the Teensy's ability to do USB Audio. &nbsp;On my laptop, I'm using the Arduino IDE to set the compressor's parameters (again, I'm using the "fast" configuration) and I'm using Audacity to send the audio to the Teensy and to record the audio returned by the Teensy.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-7J4r_dMzf_A/WH2AXfVa1hI/AAAAAAAAEJM/wrHvWeCx-ys_d7KIHcjXq8p2qDmTDy2-gCLcB/s1600/TestingCompressor.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="298" src="https://2.bp.blogspot.com/-7J4r_dMzf_A/WH2AXfVa1hI/AAAAAAAAEJM/wrHvWeCx-ys_d7KIHcjXq8p2qDmTDy2-gCLcB/s400/TestingCompressor.png" width="400" /></a></div><br /><u>Testing, Amplitude Sweep:</u>&nbsp; For my first test, I generated a steady 2kHz tone whose amplitude increases from quiet to loud at a rate of about 6 dB/sec (my test signals are shared <a href="https://github.com/chipaudette/OpenAudio_blog/tree/master/2017-01-18%20Basic%20Compressor/Testing">here</a>). &nbsp;This is the signal that I'm sending to the Teensy (also shown in blue in the figure below). &nbsp;When sending this signal, the compression algorithm on the Teensy returns the signal shown in orange. &nbsp;If you look at the loudest portion of the audio (starting around time = 8 seconds) the amplitude of the orange output signal looks to be squashed compared to the blue input signal. &nbsp;This is the effect of the compressor! &nbsp;It successfully reduced the dynamic range of the audio, as intended.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-p_zd4FLNKeY/WHzEv9yvyMI/AAAAAAAAEI0/ofSr8pyLSyw-WqXyAxqSVclFVedn8V5eQCLcB/s1600/Results-AmpSweep.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="401" src="https://1.bp.blogspot.com/-p_zd4FLNKeY/WHzEv9yvyMI/AAAAAAAAEI0/ofSr8pyLSyw-WqXyAxqSVclFVedn8V5eQCLcB/s640/Results-AmpSweep.png" width="540" /></a></div><u>Quantifying the Response:</u>&nbsp; One important question is whether the compressor kicked in at the correct amplitude. &nbsp;To answer this question, I assessed the instantaneous amplitude of each signal, as shown in the bottom plot in the figure above. &nbsp;It clearly shows that the compression of the output signal begins at an amplitude that is 15 dB below full-scale. &nbsp;This is exactly the value that was specified in the example code by the call to&nbsp;<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">setThresh_dBFS()</span><span style="font-family: inherit;">. &nbsp;It is pleasing to see that the algorithm works as intended.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;"><u>Testing, Step Changes in Amplitude:</u>&nbsp; Another important question is whether the compressor is responding at the correct speed to changes in signal amplitude. &nbsp;To answer this question, I generated a test signal with instantaneous step changes in amplitude, as shown in blue in the figure below. &nbsp;The compressor's response is shown in orange.</span><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-mWHrQMn6AOk/WHzEVdQno6I/AAAAAAAAEIs/xeoJ9TUOPEMy8J0VM3sO3G1t4aScjcyoQCLcB/s1600/Results-Steps.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="401" src="https://2.bp.blogspot.com/-mWHrQMn6AOk/WHzEVdQno6I/AAAAAAAAEIs/xeoJ9TUOPEMy8J0VM3sO3G1t4aScjcyoQCLcB/s640/Results-Steps.png" width="540" /></a></div><u>Quantifying the Attack and Release:</u>&nbsp; When I extract the&nbsp;amplitude&nbsp;of each signal versus time (bottom plot), you can see that the compressor lags in its response to the step changes. &nbsp;When the input signal gets louder (say, at time = 2 sec), the compressor's 5 msec "attack" time constant allows the compressor to response very quickly. &nbsp;But, when the input signal gets quieter (say, at time = 3 sec), the compressor's 200 msec "release" time constant makes it respond more slowly. &nbsp;In my code, these time constants are used in the traditional sense of "time constant", meaning that 63% of the change (in dB) is achieved in one time constant. &nbsp;Based on the figure above, it appears that my compressor is responding at the correct speed. &nbsp;I'm pleased.<br /><br /><u>Next Steps:</u>&nbsp; With the dynamic range compressor working correctly (and sounding pretty good when used with my Teensy Hearing Aid's microphones and my headphones), I'm well on my way to completing the signal processing hardware and software for a very basic hearing aid. &nbsp;The main component that I'm still missing is some sort of frequency compensation to increase the gain on the frequencies that the listener needs to hear better, while reducing gain on those frequencies that the listener already hears well enough. &nbsp;Stay tuned!<br /><br /><u>Follow-Up:</u>&nbsp; This algorithm converts to dB and back. &nbsp;When doing the log10(x) and pow(10,x), be sure to call the correct versions and they'll run *much* faster. &nbsp;Check it out <a href="http://openaudio.blogspot.com/2017/02/for-speedy-float-math-specify-float.html">here</a>.
