---
layout: post
title: Benchmarking - FFT Speed
author: Chip
image: https://3.bp.blogspot.com/-ed59eI80oG4/V9oHutOEAwI/AAAAAAAAD6A/SvzNDf64aS0bwSGslDUycBtzp72UKxJSwCK4B/s400/Go%2BFFT.png
---


My goal is to find a good microcontroller board for doing audio processing. &nbsp;Speed is a very important concern so, in my <a href="https://openaudio.blogspot.com/2016/09/benchmarking-fir-filtering.html">last post</a>, I looked at the speeds for different boards when doing FIR filters. &nbsp;While time-domain FIR filters are an important audio processing task, I am also curious how suitable these boards are for frequency-domain processing. &nbsp;In other words, I need to know how fast they can do FFTs. &nbsp;Let's find out!<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-ed59eI80oG4/V9oHutOEAwI/AAAAAAAAD6A/SvzNDf64aS0bwSGslDUycBtzp72UKxJSwCK4B/s1600/Go%2BFFT.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="266" src="https://3.bp.blogspot.com/-ed59eI80oG4/V9oHutOEAwI/AAAAAAAAD6A/SvzNDf64aS0bwSGslDUycBtzp72UKxJSwCK4B/s400/Go%2BFFT.png" width="400" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><br /><u>Why FFT?</u>&nbsp; An FFT is a "Fast Fourier Transform", which is not a helpful name if you're not already familiar with the idea. &nbsp;FFTs are most often used when one wants to look at the frequency content (the spectrum) of audio data. &nbsp;Intriguingly, you can also do an <i>inverse</i>&nbsp;FFT (an "IFFT") to convert that frequency spectrum data back into audio data. &nbsp;By pairing the FFT with the IFFT, therefore, one can now manipulate (or mangle!) audio data in the frequency domain, which can be a more natural and easy way to construct one's audio processing algorithms. &nbsp;They key to it all is the FFT (and its computationally similar IFFT).<br /><u><br /></u><u>Microcontroller Boards</u>: &nbsp;To understand which hardware might be capable of this frequency domain approach to audio processing, I'm evaluating a range of different boards. &nbsp;In addition to spanning a range of clock speeds (16 MHz - 180 MHz), they also vary in other computationally important ways: &nbsp;one is 8-bit while the others are 32-bit, some have DSP extensions while others do not, and one has a floating-point unit (FPU) while the others do not. &nbsp;Though my testing, I'll see what's important.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-d6L419FdLdo/V9dk6ZPJdXI/AAAAAAAAD5M/BBQFmzBBubghY0TXfvVBjEZRDkzFCKGJwCK4B/s1600/Table%2Bof%2BSystems.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="125" src="https://4.bp.blogspot.com/-d6L419FdLdo/V9dk6ZPJdXI/AAAAAAAAD5M/BBQFmzBBubghY0TXfvVBjEZRDkzFCKGJwCK4B/s640/Table%2Bof%2BSystems.png" width="540" /></a></div><br /><u>My Test Software:</u>&nbsp; For all of the boards except for the FRDM-K66F, I used the Arduino IDE to write my test software. &nbsp;It's a simple program that does an FFT on dummy data of a given length. &nbsp;The program uses Arduino's "micros()" command to measure the time to complete a fixed number of FFTs. &nbsp;Easy. &nbsp;For the FRDM-K66F board, which cannot be programmed from the Arduino IDE, I had to use NXP's IDE (Kinetis Design Studio). &nbsp;The FFT functions were identical, however, regardless of which IDE I used. &nbsp;All of my software is available on my GitHub (for <a href="https://github.com/chipaudette/OpenAudio/tree/master/Arduino/Audio%20Processing%20Benchmarking">Arduino</a>, for <a href="https://github.com/chipaudette/OpenAudio/tree/master/Kinetis%20Design%20Studio/Audio%20Processing%20Benchmarking/FIR_FFT_Benchmarking">Kinetis</a>).<br /><br /><u>KissFFT Function:</u>&nbsp;&nbsp;The only difficult part of the software is the FFT function itself. &nbsp;Since I wanted to test across a variety of hardware, I wanted to start with an FFT routine that was written in generic C. &nbsp;From the FFTW website, I found an interesting <a href="http://www.fftw.org/benchfft/">comparison of different FFT routines</a>. &nbsp;From their <a href="http://www.fftw.org/benchfft/ffts.html">list</a>, one of the most generic routines appeared to be the "<a href="https://sourceforge.net/projects/kissfft/">KissFFT</a>". &nbsp;After downloading it,&nbsp;I refactored the KissFFT code to enable different data types (Int16 vs Int32 vs Float32) and to remove the dynamic allocation of memroy via malloc(). &nbsp;With these changes, it was much more suitable for use on a microcontroller.<br /><br /><u>Raw Results:</u>&nbsp; The raw results of my speed tests are <a href="https://github.com/chipaudette/OpenAudio/blob/master/Arduino/Audio%20Processing%20Benchmarking/FFT%20Speed%20Results.xlsx">here</a>, from which I made the summary table shown below. &nbsp;The table shows the number of FFTs per second that each board could complete. &nbsp;I performed the tests for different data types (Int16, Int32, Float32) and for different FFT lengths (N=32 to N=512). &nbsp;This table is too dense to read, so let's skip ahead.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-rrW_z6hQV5Q/V9dg8-0bpMI/AAAAAAAAD3o/vfUGpMbMVvcOiN8ZJcJ_1LpexPq-zkA8QCK4B/s1600/Table%2Bof%2BFFT%2BSpeeds.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="412" src="https://4.bp.blogspot.com/-rrW_z6hQV5Q/V9dg8-0bpMI/AAAAAAAAD3o/vfUGpMbMVvcOiN8ZJcJ_1LpexPq-zkA8QCK4B/s640/Table%2Bof%2BFFT%2BSpeeds.png" width="540" /></a></div><br /><u>Speed vs FFT Length</u>: &nbsp;First, let's look at the overall flow of the data. &nbsp;The plot below shows the FFT speed for different FFT lengths. &nbsp;For FFTs using more data points, I would expect slower performance. &nbsp;This graph confirms that expectation. &nbsp;Good. &nbsp;This graph also shows that the relative ranking of the different boards is the same, regardless of the length of the FFT. &nbsp;This allows me to greatly simplify the rest of the plots.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-QDyPlB63_Ng/V9k5D_aVtsI/AAAAAAAAD5c/hezN-a2aQjssOs3i5n-NKt3l1BjYwWQVwCLcB/s1600/FFTs%2BPer%2BSecond.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="282" src="https://4.bp.blogspot.com/-QDyPlB63_Ng/V9k5D_aVtsI/AAAAAAAAD5c/hezN-a2aQjssOs3i5n-NKt3l1BjYwWQVwCLcB/s640/FFTs%2BPer%2BSecond.png" width="480" /></a></div><br /><u>Speed for Integer Data</u>: &nbsp;As the length of the FFT doesn't matter for the relative rankings, I chose to focus on an FFT size of 128. &nbsp;I chose this value because, when operating on audio data sampled at 44100 Hz, N=128 yields a frequency resolution of 344 Hz, which is a reasonably useful value. &nbsp;The graph below compares the speeds of the different boards for doing 128-point FFT on Int32 data. &nbsp;The Arduino Uno didn't have enough memory to complete this test, so it is excluded. &nbsp;Otherwise, I see that the Arduino M0 is the slowest and that the FRDM-K66F is, by far, the fastest. &nbsp;The only surprise in this data is the slowness of the Arduino M0. &nbsp;It is much slower compared to the Teensy or Maple than is expected based on their relative clock speeds. &nbsp;My data shows that Teensy can do ~4x the number of FFTs even though its clock speed is only ~2x higher. &nbsp;Clearly the M0 is not optimized for these kinds of calculations.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-QqoWq-6qPss/V9dhMbFCwUI/AAAAAAAAD4A/c78-zDd5c2I52tOSAvK2jDZuypupzQsJACK4B/s1600/FFTs%2BPer%2BSecond%2B-%2BInt32.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="243" src="https://1.bp.blogspot.com/-QqoWq-6qPss/V9dhMbFCwUI/AAAAAAAAD4A/c78-zDd5c2I52tOSAvK2jDZuypupzQsJACK4B/s640/FFTs%2BPer%2BSecond%2B-%2BInt32.png" width="449" /></a></div><br /><u>Can They Do Floating Point?</u>&nbsp; For audio processing projects, I hope to do all of processing using floating point data types (Float32). &nbsp;Being able to utilize floating point math (Float32) instead of fixed point math (Int16 and Int32) makes the algorithms much easier to design, debug, and optimize. &nbsp;The difficulty is that microcontrollers tend to be very slow with floating point calculations. &nbsp;So, let's do some tests with Floats and see if any of my boards are fast enough.<br /><br /><u>FFT Speed for Float32:</u>&nbsp;&nbsp;The graph below shows the FFT speeds that I measured using Float32 audio data. &nbsp;As can be seen by the red bars, the M0, Maple, and Teensy are very slow on Floats. &nbsp;They can only do 1/3rd as many Float32 FFTs and they can Int32 FFTs. &nbsp;That is a major speed penalty. &nbsp;The major exception to this trend is the FRDM-K66F. &nbsp;It is actually <i>faster</i>&nbsp;using Float32 than Int32. &nbsp;Presumably, this is due to the float-point unit (FPU) included in the K66F chip. &nbsp;Even with the FPU, I did not expect it to be faster on Floats than Ints. &nbsp;Very surprising.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-ybwztoV6duQ/V9dhU5hyVCI/AAAAAAAAD4I/75nX3KbR8DAX-3yjjtOj3aPQevlVT1EVACK4B/s1600/FFTs%2BPer%2BSecond%2B-%2BInt%2Band%2BFloat.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="243" src="https://3.bp.blogspot.com/-ybwztoV6duQ/V9dhU5hyVCI/AAAAAAAAD4I/75nX3KbR8DAX-3yjjtOj3aPQevlVT1EVACK4B/s640/FFTs%2BPer%2BSecond%2B-%2BInt%2Band%2BFloat.png" width="449" /></a></div><br /><u>DSP Acceleration:</u>&nbsp; Because an FFT is such a common digital signal processing (DSP) task, some processors include internal features to accelerate this kind of math. &nbsp;The Teensy 3.2 and the FRDM-K66F are both based on the Arm Cortex M4 processor core. &nbsp;The Cortex M4 includes DSP acceleration. &nbsp;I learned that I can invoke the ARM's DSP accelerators by calling the FFT functions from ARM's "CMSIS" library. &nbsp;It took me some effort to figure it out, but I eventually got it to work. &nbsp;And, boy, did it work well...<br /><br /><u>FFT Speed Using CMSIS:</u>&nbsp; My results using the CMSIS library are shown below. &nbsp;Using the CMSIS routines (and the underlying hardware acceleration) really speeds up the FFTs.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-BCv7zy38vK8/V9dhbXLlnJI/AAAAAAAAD4Q/C-NrGNla1u8PRxvdas7UXyjnSILCY51HwCK4B/s1600/FFts%2BPer%2BSecond%2Bwith%2BCMSIS.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="243" src="https://4.bp.blogspot.com/-BCv7zy38vK8/V9dhbXLlnJI/AAAAAAAAD4Q/C-NrGNla1u8PRxvdas7UXyjnSILCY51HwCK4B/s640/FFts%2BPer%2BSecond%2Bwith%2BCMSIS.png" width="540" /></a></div><br />The effect of the CMSIS / DSP accelerators is so dramatic that I quantified the improvement in the table below. &nbsp;The speed improvement is different for the different data types. &nbsp;Using Int16 data, the CMSIS routines are 4-5x faster than the Generic C "KissFFT" routines. &nbsp;Wow. &nbsp;For the In32 data, CMSIS is 3x faster and for Float32 data, CMSIS is 2x faster. &nbsp;This extra speed is definitely a good reward for the effort spent to figure out how to use the CMSIS library.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-a6e9bNcoyOw/V9oD0fOMyeI/AAAAAAAAD54/AbUcoOY0Oscf5yOefoGKaiEE82nDNET5QCK4B/s1600/CMSIS%2BSpeedup.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="99" src="https://2.bp.blogspot.com/-a6e9bNcoyOw/V9oD0fOMyeI/AAAAAAAAD54/AbUcoOY0Oscf5yOefoGKaiEE82nDNET5QCK4B/s320/CMSIS%2BSpeedup.png" width="240" /></a></div><br /><u>How Fast is Fast Enough?</u>&nbsp; I want to know which boards are fast enough to enable frequency-domain processing of audio signals. &nbsp;As I discussed earlier, frequency-domain processing requires that I perform an FFT to get into the frequency domain and then an IFFT (which takes the same amount of time as an FFT) to get back out of the frequency domain. &nbsp;Given my measured FFT speed values, I can estimate the maximum audio sample rate that each board can sustain:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">max_sample_rate_Hz = (FFTs_per_second * N_FFT / 2) * (1 - overlap)</span><br /><br />In this equation, the "2" accounts for the need to do both an FFT and an IFFT. &nbsp;The "overlap" term accounts for the fact that most people do frequency-domain processing using blocks of audio samples that overlap by 50% (0.5) in order to smooth out any artifacts at the ends of the audio blocks.<br /><br /><u>Maximum Sample Rate for Frequency-Domain Processing:</u>&nbsp; Using this equation, assuming an N=128, and assuming an overlap of 0.5, the table below shows the maximum sample rate that each board can support for frequency-domain processing. &nbsp;I've highlighted in green those boards that can sustain this kind of processing at sample rates appropriate for audio (ie, greater than 44100 Hz). <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-7WVVai7-g1s/V9dhkjakuBI/AAAAAAAAD4g/tAVdSFZ9_-U8bZRGu34rdhA4SLHJddqMgCK4B/s1600/Table%2Bof%2BMax%2BSample%2BRate.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="115" src="https://4.bp.blogspot.com/-7WVVai7-g1s/V9dhkjakuBI/AAAAAAAAD4g/tAVdSFZ9_-U8bZRGu34rdhA4SLHJddqMgCK4B/s640/Table%2Bof%2BMax%2BSample%2BRate.png" width="540" /></a></div><br /><u>Conclusion:</u>&nbsp; If my goal is to do frequency-domain processing using Float32 data, only the FRDM-K66F is fast enough. &nbsp;That is my primary conclusion. &nbsp;My secondary conclusions are that, if I use Int32 data, the CMSIS acceleration means that the Teensy 3.2 is a viable option. &nbsp;Furthermore, if I can tolerate Int16 data, I can choose from the Maple, Teensy, or K66. &nbsp;But I don't want to do that. &nbsp;I want to use Floats. &nbsp;So, the K66F is for me.<br /><br /><u>Looking Forward:</u>&nbsp; While the FRDM-K66F board is very powerful for doing FFT operations, it is difficult for me to program. &nbsp;I prefer the simplicity of the Arduino IDE, yet the FRDM-K66F is not supported by Ardiuno. &nbsp;Looking forward however, the folks who do Teensy are about to release the "Teensy 3.6", which uses the same (or similar) processor as is used in the FRDM-K66F. &nbsp;Since Teensy is programmable from the Arduino IDE, I am hoping that we'll soon have the power of the K66F combined with the ease-of-use of the Teensy. &nbsp;That will be a truly winning combination for open source audio processing.
