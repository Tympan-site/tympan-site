---
layout: post
title: Benchmarking - FIR Filtering
author: Chip
image: https://2.bp.blogspot.com/-Zr-CM8_YP3c/V81xNxutw-I/AAAAAAAAD1U/6TicbDv6dZUPvCQjval1qrxox9naaKVRQCLcB/s400/IMG_6489-001.JPG
---


I want to do real-time audio processing. &nbsp;And, I want to do it using small electronics without having to fight with an operating system like Windows or Linux. &nbsp;Most of my <a href="http://eeghacker.blogspot.com/">previous </a><a href="http://synthhacker.blogspot.com/">experience </a>with electronics hacking&nbsp;has been with Arduino (or Arduino-like) platforms. &nbsp;Audio processing, however, is pretty computationally demanding. &nbsp;I need to find an easy-to-use board that is fast for typical audio tasks. &nbsp;So, as a first step, I'm going to get a bunch of different boards and see which can do FIR filtering at audio rates. &nbsp;Let's see which boards are up to the task!<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://2.bp.blogspot.com/-Zr-CM8_YP3c/V81xNxutw-I/AAAAAAAAD1U/6TicbDv6dZUPvCQjval1qrxox9naaKVRQCLcB/s1600/IMG_6489-001.JPG" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="266" src="https://2.bp.blogspot.com/-Zr-CM8_YP3c/V81xNxutw-I/AAAAAAAAD1U/6TicbDv6dZUPvCQjval1qrxox9naaKVRQCLcB/s400/IMG_6489-001.JPG" width="400" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Top: Arduino Uno, Arduino M0, LeafLabs Maple. &nbsp;Bottom: Teensy 3.2 and FRDM-K66F.</td></tr></tbody></table><br /><u>The Competitors:</u>&nbsp; I chose to test six different boards -- many of which I already had kicking around the house. &nbsp;The six boards that I tested are summarized in the table below. &nbsp;As you can see, I tried everything from the lowly Arduino Uno up to the mighty Teensy 3.2 and the even-mightier FRDM-K66F. &nbsp;While the FRDM-K66F is a bit obscure, I'm using it as a proxy for the up-coming <a href="https://www.kickstarter.com/projects/paulstoffregen/teensy-35-and-36">Teensy 3.6</a>, which uses the same K66F chip. &nbsp;Its fast 180 MHz clock speed and its floating point unit (FPU) should make the FRDM-K66F / Teensy 3.6 great for processing audio.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-1keyZQDCxII/Wdt62GIg_AI/AAAAAAAAEUY/w3rUXGRbQgg5VFyoBdRRg5cHDfiUUxB1QCLcBGAs/s1600/Table%2Bof%2BSystems.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="371" data-original-width="1438" height="143" src="https://3.bp.blogspot.com/-1keyZQDCxII/Wdt62GIg_AI/AAAAAAAAEUY/w3rUXGRbQgg5VFyoBdRRg5cHDfiUUxB1QCLcBGAs/s640/Table%2Bof%2BSystems.png" width="560" /></a></div><br /><u>Why FIR Filters?</u>&nbsp; If you want to manipulate the frequency content of an audio stream, you need a filter. &nbsp;Boosting the bass? &nbsp;Cutting some mids? &nbsp;Boosting the treble? &nbsp;Apply the appropriate filter. &nbsp;There are many kinds of filters, typically divided into either IIR filters or FIR filters. &nbsp;I'm not yet ready to dive into the differences between IIR vs FIR, but I tend to prefer FIR filters for their linear phase and unconditional stability (a good discussion of FIR filters is <a href="http://dspguru.com/dsp/faqs/fir/basics">here</a>&nbsp;and <a href="http://www.barrgroup.com/Embedded-Systems/How-To/Digital-Filters-FIR-IIR">here</a>). &nbsp;Regardless, FIR filters are a good, basic audio processing task that make for a widely-applicable benchmark.<br /><br /><u>Lots of Multiplies and Adds:</u>&nbsp;&nbsp;The challenge with FIR filters is that they can require a processor to do a lot of computation -- a lot of multiply and addition operations. &nbsp;The finer the frequency resolution desired, the more multiplies and adds are needed to do the filter. &nbsp; The resolution of an FIR filter scales with the length of the filter (the "N" of the filter). &nbsp;As a simple rule-of-thumb, an FIR filter's workload scales as:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">N_FIR = sample_rate_Hz /&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">freq_res_Hz</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">; &nbsp; &nbsp; &nbsp;//approximate</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">num_multiplies = N_FIR * sample_rate_Hz; &nbsp; //same for num_adds</span><br /><br />For example, if you want a frequency resolution of 250 Hz, and if your sample rate is 44 kHz, then you need an FIR filter length N = (44000/250) = &nbsp;176. &nbsp;To actually filter the audio, you need to apply this 176-point filter to every audio sample in your 44 kHz audio stream. &nbsp;To keep up, your processor will need to do at least (176*44000) = 7.7 million multiplications plus 7.7 million additions per second. &nbsp;That's a lot of work to do! &nbsp;Which of my boards are capable of this?<br /><br /><u>FIR Software:</u>&nbsp; To test the FIR speed of each board, I used the Arduino IDE and wrote a very naive implementation of an FIR filter (yes, faster results could definitely be achieved, but this test is just trying to get a sense of relative speeds of the platforms). &nbsp;My code uses the Arduino's "micros()" command to measure the time to repeat the FIR filter numerous times. &nbsp;For the K66 board, which could not be programmed through the Arduino IDE (until the Teensy 3.6 comes out!), I had to use NXP's "Kinetis Design Studio" to write the software, but the FIR function itself is the same. &nbsp;All of the code is available in my <a href="https://github.com/chipaudette/OpenAudio">OpenAudio </a>repository on GitHub.<br /><br /><u>Results, All Data:</u>&nbsp; My raw data (<a href="https://github.com/chipaudette/OpenAudio/raw/master/Arduino/Audio%20Processing%20Benchmarking/FIR%20Speed%20Results.xlsx">here</a>) consist of the time required to perform FIR filters on the different platforms. &nbsp;To ease the presentation of the data, I invert the values so that it tells me the number of FIR filters that can be completed per second. &nbsp;In this perspective, a bigger number means it can do more FIRs per second, which is good. &nbsp;My results are shown in the table below. &nbsp;It shows the FIR speeds for different filter lengths (16-256) and for two different data types (Int32 and Float32). &nbsp;Because I find tables difficult to read, let's jump over the table and make some plots that better illustrate the results.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div style="text-align: center;"><a href="http://1.bp.blogspot.com/-MXPMDEFHb5A/V89kCTEGG5I/AAAAAAAAD2E/26dDOmCJc9I1cKMVAQVsMEA_tEZqGGQXQCK4B/s1600/Table%2B-%2BFIR%2BPer%2BSecond.png" imageanchor="1"><img border="0" height="250" src="https://1.bp.blogspot.com/-MXPMDEFHb5A/V89kCTEGG5I/AAAAAAAAD2E/26dDOmCJc9I1cKMVAQVsMEA_tEZqGGQXQCK4B/s640/Table%2B-%2BFIR%2BPer%2BSecond.png" width="560" /></a></div><br /><u>Results, Effect of "N":</u>&nbsp; Longer filters require more computations, so I would expect longer filters to be slower. &nbsp;Using data from the big table above, the plot below confirms that expectation. &nbsp;Also, note that all of the lines show the same slope and that the lines never cross each other. &nbsp;This means that the relative ranking of the different boards stays the same across all FIR filter lengths, which allows me to greatly simplify the rest of the plots.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-MEOYdRi8n68/V89kWJrY-0I/AAAAAAAAD2I/fUt7z1V_p3IvWido0HIOmX4qH2bW9ou1wCLcB/s1600/Speed%2Bvs%2BN.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="266" src="https://2.bp.blogspot.com/-MEOYdRi8n68/V89kWJrY-0I/AAAAAAAAD2I/fUt7z1V_p3IvWido0HIOmX4qH2bW9ou1wCLcB/s640/Speed%2Bvs%2BN.png" width="540" /></a></div><br /><u>Results, Speed of Each Board (Int32)</u>: &nbsp;Since the relative ranking of the boards stays the same throughout, let's illustrate the relative speed of each board by picking just one filter length. &nbsp;The plot below picks N=128. &nbsp;It shows the speed when using Int32 data. &nbsp;On the left side of the plot, note that the Arduino Uno is very slow on Int32 values. &nbsp;Presumably its 8-bit processor has difficulty with the 32-bit data type. &nbsp;On the right side of the plot, the fastest board is the K66F, which is 100 times faster than the Uno. &nbsp;That's a huge difference!<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-SfpBVseGP4E/V89kafnDaGI/AAAAAAAAD2Q/pl-8bAtnXBIUyfr-67UAPYqdNcgLBgc1QCK4B/s1600/Speed%2Bvs%2BBoard.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="283" src="https://2.bp.blogspot.com/-SfpBVseGP4E/V89kafnDaGI/AAAAAAAAD2Q/pl-8bAtnXBIUyfr-67UAPYqdNcgLBgc1QCK4B/s640/Speed%2Bvs%2BBoard.png" width="540" /></a></div><br /><u>Results, Floating Point:</u>&nbsp; The below below is the same, but I add in the results for floating point data (Float32). &nbsp;Writing audio processing algorithms using Float operations is much easier than using Int operations, so these are the results that I'm most interested in. &nbsp;As can be seen in the plot, these boards are *much* slower on Floats than on Ints. &nbsp;The major exception to this result is the K66F board, which is basically as fast on Floats as it is on Ints. &nbsp;That's amazing! &nbsp;This result clearly reflects the fact that the K66 is the only processor in this comparison which has an FPU.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-wkrrgxLx34I/V89kfumXzyI/AAAAAAAAD2Y/C8TqxRCyXXEGqmRjE_LwBJjB2T4V6FPowCK4B/s1600/Speed%2Bvs%2BBoard%2B-%2BwFloat.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="283" src="https://3.bp.blogspot.com/-wkrrgxLx34I/V89kfumXzyI/AAAAAAAAD2Y/C8TqxRCyXXEGqmRjE_LwBJjB2T4V6FPowCK4B/s640/Speed%2Bvs%2BBoard%2B-%2BwFloat.png" width="540" /></a></div><br /><u>How Fast is Fast Enough?</u>&nbsp; Deciding what FIR speed is "fast enough" for audio processing is not a simple question. &nbsp;One approach is to return back to the example at the top of this post: a hypothetical 176-point FIR filter. &nbsp;This filter length was chosen because it would yield a frequency resolution of 250 Hz when run at an audio sample rate of 44 kHz. &nbsp;Which of these boards can support such a long filter at this fast sample rate? &nbsp;Well, by scaling the N=128 speed values to N=176, the table below shows the sample rate that could be sustained by each board. &nbsp;As can be seen the Teensy 3.2 is fast enough for audio processing using Ints. &nbsp;But, if I want to do Floats, only the K66F is fast enough.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-zsncti-i_38/V89xPQ17QqI/AAAAAAAAD3Q/8Z1BgoZmTSMxNMgcfXzWsnwRZ1zDDenyACK4B/s1600/Sustained%2BSample%2BRate.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="91" src="https://2.bp.blogspot.com/-zsncti-i_38/V89xPQ17QqI/AAAAAAAAD3Q/8Z1BgoZmTSMxNMgcfXzWsnwRZ1zDDenyACK4B/s640/Sustained%2BSample%2BRate.png" width="560" /></a></div><br /><u>Programming the K66F:</u>&nbsp; Unfortunately, the FRDM-K66F board is not programmable from the Arduino IDE. &nbsp;This makes it much harder to setup and debug by non-professionals. &nbsp;This a real hurdle. &nbsp;Luckily, the upcoming Teensy 3.6 also uses the K66 processor. &nbsp;Since the Teensy products are all compatible with the Arduino IDE, it means that the power of the K66 will soon be far more accessible. &nbsp;That's the solution that I'm really looking for. &nbsp;So, I supported the Teensy 3.6 kickstarter. &nbsp;I can't wait to get my Teensy 3.6!<br /><br /><div><u>Next Steps:</u>&nbsp; FIR filtering is not the only audio processing task that one might like to do. &nbsp;An FFT is another important type of operation that is computationally intense. &nbsp;In my next post, I'll look at the FFT speeds to see which boards are capable of real-time, frequency-domain processing. &nbsp;Until then, have some happy hacking!<br /><br /><u>Update</u>: FFT Benchmarking Results are <a href="http://openaudio.blogspot.com/2016/09/benchmarking-fft-speed.html">here</a>!</div>
