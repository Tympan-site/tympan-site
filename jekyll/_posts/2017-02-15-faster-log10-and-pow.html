---
layout: post
title: Faster Log10 and Pow
author: Chip
---


<div class="tr_bq">After my previous post, which showed a tremendous increase in speed by choosing float-specific math functions (ie, "log10f") versus their generic counterpart (ie, "log10"), I still wasn't satisfied with the speed of my audio processing on the Teensy 3.6. I had some calculations that went into and out of dB space, which means I needed to do lots of log10f(x) and pow(10,x) function calls. I needed them to be faster. &nbsp;Here's how I did it...</div><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-dwLOA4FrQpA/WKTGGg4oDAI/AAAAAAAAEKg/ZKUMjfkE6TIiCTjLYOR7_Z747RA0CgRMwCLcB/s1600/Plot_FloatVsReformulated.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="295" src="https://3.bp.blogspot.com/-dwLOA4FrQpA/WKTGGg4oDAI/AAAAAAAAEKg/ZKUMjfkE6TIiCTjLYOR7_Z747RA0CgRMwCLcB/s640/Plot_FloatVsReformulated.png" width="540" /></a></div><br /><div style="text-align: center;"></div><u>They Should be Faster:</u>&nbsp; The figure above shows the number of CPU cycles that I measured for each math function. &nbsp;The red bars are using the standard math function. &nbsp;What caught my eye was that the log10f() function is slower than the logf() function. &nbsp;They should only be different by one multiplication (ie, 1-2 cycles). &nbsp;Similarly, I was surprised that powf(10.0,x) was so much slower than expf(x). &nbsp;It seemed like I ought to be able to accelerate these functions.<br /><br /><u>Faster powf():</u>&nbsp; I started with powf() it was in the most need of acceleration. &nbsp;Because I did not need a general powf() command that could do any base number, I could optimize specifically for powf(10.0,x). &nbsp;Through the rules of exponential and logs, I wrote my own macro that executed pow in terms of exp:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">//powf(10.f,x) is exactly exp(log(10.0f)*x)</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">#define pow10f(x) expf(2.302585092994046f*x)</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;"> &nbsp;</span><br /><br />Note that the reformulation above is not a numerical approximation. &nbsp;If you had all of the digits for that 2.302 constant, this would be an exact substitution for pow(10,x). &nbsp;Yet, as you'll see in a moment, it is 3 times faster. &nbsp;Way faster with no loss in accuracy. &nbsp;Wow!<br /><br /><u>Faster log10f():</u>&nbsp; Similarly, for log10f(), I started with a reformulating log10 in terms of log. &nbsp;While that was effective, it was only a modest increase in speed. &nbsp;I wanted it even faster. &nbsp;So, in a post in the ARM community forum (<a href="https://community.arm.com/tools/f/discussions/4292/cmsis-dsp-new-functionality-proposal/22621#22621">here</a>), I found that someone (thanks Dr. Beckmann!) had reformulated log10f using log base 2 and then further accelerated it using an approximation for log base 2 that exploits way that single-precision numbers are represented in memory. &nbsp;It's a pretty neat solution. <br /><br />So, using this, my complete substitution for log10f() is shown below. &nbsp;The log2 approximation function is at the end of this post.<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">//log10f is exactly log2(x)/log2(10.0f)</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">#define log10f_fast(x) &nbsp;(log2f_approx(x)*0.3010299956639812f)</span><br /><br />Because this reformulation uses an approximation for log2(), it is not an exact substitution. &nbsp;But, over the range of input values that I explored, the resulting error seemed to be less than 0.05%, which is good enough for my needs.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-XWEJlm1-yjA/WKTE2GiBYbI/AAAAAAAAEKY/lh8ilIoqePc_nigaWC9-AEzvjdUz0ogtgCLcB/s1600/table_substitute.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="154" src="https://3.bp.blogspot.com/-XWEJlm1-yjA/WKTE2GiBYbI/AAAAAAAAEKY/lh8ilIoqePc_nigaWC9-AEzvjdUz0ogtgCLcB/s320/table_substitute.png" width="320" /></a></div><br /><u>Faster by 3x!</u>&nbsp;&nbsp;In looking at the speed of these to reformulated functions, I saw that my log10f approximation was 2.8x faster than the standard log10f(). &nbsp;Similarly, I found that my pow10f function was 3.0x faster than the standard powf(10,x) function call. &nbsp;That's a pretty nice acceleration! &nbsp;I'm pleased.<br /><br />As promised, here's the fast log2 approximation (<a href="https://community.arm.com/tools/f/discussions/4292/cmsis-dsp-new-functionality-proposal/22621#22621">source</a>):<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">// This is a fast approximation to log2()</span><br /><div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">// Y = C[0]*F*F*F + C[1]*F*F + C[2]*F + C[3] + E;</span></div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">float log2f_approx(float X) {<br />&nbsp; float Y, F;<br />&nbsp; int E;</span><br /><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; F = frexpf(fabsf(X), &amp;E);<br />&nbsp; Y = 1.23149591368684f;<br />&nbsp; Y *= F;<br />&nbsp; Y += -4.11852516267426f;<br />&nbsp; Y *= F;<br />&nbsp; Y += 6.02197014179219f;<br />&nbsp; Y *= F;<br />&nbsp; Y += -3.13396450166353f;<br />&nbsp; Y += E;<br />&nbsp; return(Y);<br />}</span></div></div>
